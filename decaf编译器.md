## Decaf
在已提供的decaf语言mips编译器的基础上，我们实现了decaf语言的Risc-V编译器，并成功将使用decaf高级语言编写的应用程序交叉编译为.S文件在uCore操作系统的调度下在SystemOnCat上运行

### Decaf 编译器后端简介
Decaf编译器的前端工作到生成三地址码为止，接下来的后端工作主要有以下几个部分：

1. 将原有的三地址码划分为基本块，进行简单的数据流分析，构造数据流图，并进行简单的代码优化

2. 进行指令选择，将原有的三地址码的指令替换为对应平台支持的指令

3. 进行寄存器分配，将原有三地址码中无限的寄存器替换为对应平台支持的有限量的寄存器

4. 根据对应平台上的操作系统，添加相对应的系统调用，并将系统调用库函数和生成的.S汇编代码链接生成可执行文件

接下来我们分别介绍在基于Risc-V32的SystemOnCat计算机系统中，上述四个部分的具体实现

### 划分基本块和构建数据流图
基本块划分是代码分析的第一步，SystemOnCat系统保留了原有mips编译器系统的实现方法，以出口语句（包括Return, Beqz, Bnez, Branch）为标志将原有的三地址码划分为一系列基本块，每一个基本块有它的后继基本块，同时还记录了每一个基本块中的活跃变量信息（如Def集合，LiveUse集合，LiveIn集合，LiveOut集合等），基于这些活跃变量信息，我们可以得到离开基本块时必须保存的寄存器集合

划分好基本块以后，可以在此基础上构建流图，流图体现了基本块之间的信息，对于一些不可达的基本块可以进行删除，从而实现简单的代码优化

### 指令选择
由于原有的decaf编译器是面向mips平台的，因此我们需要将相应的mips指令都替换为Risc-V指令，这些Risc-V指令需要保证和三地址码指令等价

基本上大部分三地址码指令都能够在Risc-V指令集中找到和它对应的指令，只有各别指令需要做一些替换，以下是部分需要用多条Risc-V指令来实现的三地址码指令
1. GEQ指令，要求在针对两个操作数比较时，A大于等于B则返回1，否则返回0，但是在Risc-V指令中只有SLT指令，即A小于B返回1，否则返回0，所以这条指令可以看成是和SLT意义恰好相反的指令，因此可以使用SLT和异或0实现
2. EQU指令，要求在针对两个操作数比较时，A等于B则返回1，否则返回0，可以使用Risc-V指令中的减法指令和判断是否为0的指令来组合实现
3. GTR指令，和SLT指令的意义恰好相反，因此只需要交换A，B操作数即可

此外由于SystemOnCat平台目前只支持Risc-V32IA系列指令，并没有实现M类型指令（包括各类乘除法和取余等），因此需要将乘除法和取余都改为函数调用的形式，使用软件来实现相应的逻辑，但是函数的调用有可能会破坏基本快的划分和数据流图的构建，需要提早完成这一替换过程 ———— 我们修改了decaf编译器的前端，在生成三地址码时就实现替换，保证对应代码中没有MUL, DIV, MOD等指令，将他们统统修改为IntrinsicCall的形式

### 寄存器分配
由于原有的三地址码可以使用的寄存器是无穷多的，因此需要使用一定的分配算法将无穷个寄存器替换为有限多个，由于该分配算法和平台无关，因此我们保留了原有的mips编译器的相关实现

但是由于mips寄存器和Risc-V寄存器的名称和使用规范是不同的，因此需要针对原有的寄存器名称进行修改，同时需要指定哪些寄存器属于通用寄存器

### 系统调用
为了能够获得平台的服务，每一个Risc-V应用程序需要能够通过系统/库函数调用来实现诸如输入，输出，内存分配，退出，乘法，除法，取余等操作，这些调用是和平台密切相关的，下面介绍一个简单的系统调用（如输出一个字符串）的实现流程：
1. 在.S文件中的代码段的起始位置会有一个简单的调用入口 _PrintString，其中实现了参数的传递，针对真正的库函数（_catlib__Printstring)的调用，以及调用结束之后的返回等一系列操作，在整个汇编代码中每一个需要输出字符串的位置就调用 call _Printstring 即可
2. 真实的库函数是使用c编写的catlib.c文件，这个文件使用Risc-V自带的工具链编生成对应的.o文件，由于我们的编译器和Risc-V自带工具链的编译器的调用规范保持了较好的一致性，因此可以直接将我们自己的编译生成的.S经过汇编器生成的.o与库函数的.o链接生成可执行文件
3. 在catlib.c文件中的_catlib__PrintString函数调用了uCore中提供的用户库函数cprintf，该函数将通过系统调用的形式要求uCore提供相应的服务

关于其他函数调用功能，如乘法，除法，取余等的实现过程类似，只不过catlib.c中调用的用户库函数直接在用户态就实现了相应的功能，而不需要通过系统调用的形式切换到内核态再实现相应的功能了

### 实验结果
我们最终成功在自己的硬件上运行了uCore操作系统，并在操作系统的调度下运行了blackjack.decaf, math.decaf, fabonacci.decaf等应用程序

交叉编译器的具体使用方法参考DeCat文件夹下的Readme文件